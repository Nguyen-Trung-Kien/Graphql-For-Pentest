# Graphql-For-Pentest
learning graphql for pentest
Graphql là ngôn ngữ truy vấn cho API và cho phép thực thi trên máy chủ để trả về kết quả tương ứng. Graphql không ràng buộc loại cơ sở dữ liệu hoặc công cụ lưu trữ cụ thể nào, thay vào đó được hỗ trợ bởi code và dữ liệu hiện có.

## Tips pentest graphql
1. Luôn kiểm tra introspection
```
{__schema{types{name,fields{name}}}}
```
2. Thử %0a , %0d hoặc %0d%0a ở sau __schema hoặc type, hãy tuỳ biến để bypass việc tắt introspection
3. Sử dụng fragment để kiểm tra các input đầu vào
```
query+IntrospectionQuery+%7B%0A++__schema+%7B%0A++++queryType+%7B%0D%0A++++++name%0D%0A++++%7D%0D%0A++++mutationType+%7B%0D%0A++++++name%0D%0A++++%7D%0D%0A++++subscriptionType+%7B%0D%0A++++++name%0D%0A++++%7D%0D%0A++++types+%7B%0D%0A++++++...FullType%0D%0A++++%7D%0D%0A++++directives+%7B%0D%0A++++++name%0D%0A++++++description%0D%0A++++++args+%7B%0D%0A++++++++...InputValue%0D%0A++++++%7D%0D%0A++++%7D%0D%0A++%7D%0D%0A%7D%0D%0A%0D%0Afragment+FullType+on+__Type+%7B%0D%0A++kind%0D%0A++name%0D%0A++description%0D%0A++fields%28includeDeprecated%3A+true%29+%7B%0D%0A++++name%0D%0A++++description%0D%0A++++args+%7B%0D%0A++++++...InputValue%0D%0A++++%7D%0D%0A++++type+%7B%0D%0A++++++...TypeRef%0D%0A++++%7D%0D%0A++++isDeprecated%0D%0A++++deprecationReason%0D%0A++%7D%0D%0A++inputFields+%7B%0D%0A++++...InputValue%0D%0A++%7D%0D%0A++interfaces+%7B%0D%0A++++...TypeRef%0D%0A++%7D%0D%0A++enumValues%28includeDeprecated%3A+true%29+%7B%0D%0A++++name%0D%0A++++description%0D%0A++++isDeprecated%0D%0A++++deprecationReason%0D%0A++%7D%0D%0A++possibleTypes+%7B%0D%0A++++...TypeRef%0D%0A++%7D%0D%0A%7D%0D%0A%0D%0Afragment+InputValue+on+__InputValue+%7B%0D%0A++name%0D%0A++description%0D%0A++type+%7B%0D%0A++++...TypeRef%0D%0A++%7D%0D%0A++defaultValue%0D%0A%7D%0D%0A%0D%0Afragment+TypeRef+on+__Type+%7B%0D%0A++kind%0D%0A++name%0D%0A++ofType+%7B%0D%0A++++kind%0D%0A++++name%0D%0A++++ofType+%7B%0D%0A++++++kind%0D%0A++++++name%0D%0A++++++ofType+%7B%0D%0A++++++++kind%0D%0A++++++++name%0D%0A++++++%7D%0D%0A++++%7D%0D%0A++%7D%0D%0A%7D%0D%0A
```
5. a
6. a
7. a
## Cấu trúc
Các Thành phần của graphql :
1. Operation Type
- Query: Sử dụng để lấy dữ liệu từ máy chủ
- Mutation: Sử dụng để sửa đổi dữ liệu trên máy chủ
- Subscription: Sử dụng để thiết lập kết nối thời gian thực để cập nhật dữ liệu
2. Operation Name
Tên do người dùng đặt
3. Selection Set
- Là các trường xác định yêu cầu dữ liệu cho việc truy vấn (tránh nạp dữ liệu quá nhiều)
- Mỗi trường đại diện cho một phần dữ liệu cần được truy xuất hoặc sửa đổi
- Các trường có thể có đối số để sử dụng cho việc lọc hoặc sắp xếp
- mặc định response key của các trường trong đối tượng phản hồi sẽ sử dụng tên của trường đó. Tuy nhiên cũng có thể xác định khoá phản hồi bằng cách chỉ định bí danh
4. Biến (Variables)
- các biến tuỳ chọn có thể được sử dụng để tham số hoá các Operation
- các biến cho phép tái sử dụng bằng cách cung cấp các giá trị khi thực hiện requests
![image](https://github.com/Nguyen-Trung-Kien/Graphql-For-Pentest/assets/65381453/68696d72-0f20-4364-9844-5ba16b2bb1f7)

Operation Type: Query -> lấy dữ liệu

Operation Name : GetBook tên người dùng đặt

Selection Set : Trường "book" chỉ định cách dữ liệu cần xem (title, author, publicationYear)

Variables (biến) : "$bookId" biến thuộc "ID!" (không null) sử dụng là đối số để tìm nạp một cuốn sách cụ thể 

arguments (đối số): id nhập vào để xác định book
5. Fragments (Phân đoạn):
- Các phân đoạn được sử dụng trong Graphql để giảm sự trùng lặp và sử dụng lại các lựa chọn trường phổ biến trong truy vấn
- Cho phép xác định một tập hợp các trường một lần và đưa vào nhiều truy vấn
- Sử dụng Fragments để làm cho các truy vấn ngắn gọn và dễ bảo trì hơn

![image](https://github.com/Nguyen-Trung-Kien/Graphql-For-Pentest/assets/65381453/1be0c61d-0c2d-4331-998c-575d40c66288)

## Schema
Schema được xem là bản thiết kế xác định hoạt động mà client có thể truy cập.

Schema xác định các loại và mối quan hệ trong graphql. Nó phát thảo các loại đối tượng và chỉ định cách các trường trong loại đó liên quan với nhau

ví dụ:
```
type Query {
  hello: String
  user(id: ID!): User
}

type User {
  id: ID!
  name: String!
  email: String!
}
```
Trong ví dụ này là Schema với 2 type là Query và User

type Query là điểm vào để seach dữ liệu từ máy chủ. Có 2 trường là hello và user
Trường hello trả về string
Trường User chấp nhận đối số id (không null) và trả về đối tượng User

type User xác định cấu trúc của đối tượng User . Có 3 trường là id, name, email.
Trường id thuộc loại ID! (không null và luôn phải có giá trị)
Trường name thuộc loại String! (không null và luôn có giá trị)

Với schema này có thể truy vấn về trường hello để nhận được chuỗi phản hồi hoặc sử dụng trường User có argument (đối số) id để truy xuất một đối tượng có id cụ thể với thông tin id, name, email

```
type Character {
  name: String!
  appearsIn: [Episode!]!
}
```
Ở ví dụ này: 
- Character là 1 loại đối tượng trong Graphql 
- name và appearsIn là các trường trong đối tượng có tên Character
- String là 1 trong những loại scalar (sẽ ở dưới tìm hiểu qua)
- String! có nghĩa là non-null (không thể không có dữ liệu)
- *[Episode!]!*  là chỉ ra rằng đây là mảng các đối tượng có tên là Episode và các đối tượng này cũng non-null , nên có thể là 1 mảng có 0 hoặc nhiều đối tượng khi truy vấn tới appearsIn. Và vì Episode! cũng non-null nên mọi mục của mảng sẽ  là một đối tượng Episode

### Arguments
Mọt trường của một đối tượng Grapql có thể có 0 hoặc nhiều đối số 

#### Đối số là giá trị mà bạn cung cấp cho một trường (field) cụ thể trong truy vấn của mình
để xác định đối số, hãy thêm dấu ngoặc đơn sau tên trường , bên trong viết tên đối số, theo sau là dấu : sau đó là loại đối số (ví dụ String, Int, vv)
Nếu có nhiều hơn một đối số, có thể phân tách các đối số bằng dấu ,
![image](https://github.com/Nguyen-Trung-Kien/Graphql-For-Pentest/assets/65381453/11bf770c-e215-457d-889a-92082b981d46)
(link)[https://www.apollographql.com/tutorials/lift-off-part3/03-graphql-arguments]
```
type Starship {
  id: ID!
  name: String!
  length(unit: LengthUnit = METER): Float
}
```
ví dụ trường length có đối số có tên là unit 

Các đối số có thể bắt buộc hoặc tuỳ chọn . Khi một đối số là tuỳ chọn , chúng ta có thể xác định một giá trị mặc định - nếu đối số unit không được truy dữ liệu nó sẽ đặt theo mặc định là METER

## QUERY AND MUTATION TYPE

Trong các schema thông thường chỉ là các loại đối tượng thông thường mà bạn định nghĩa, tuy nhiên có 2 loại đặc biệt là query và mutation

```
schema {
  query: Query
  mutation: Mutation
}
```
Một services graphql đều có một loại query và có thể có hoặc không có loại mutation. Các loại này giống như một đối tượng thông thường, nhưng đặt biệt ở chỗ 2 loại này *Xác định điểm vào của mọt truy vấn trong graphql*

ví dụ có 1 truy vấn giống như thế này

```
  hero {
    name
  }
  droid(id: "2000") {
    name
  }
}
```
và kết quả trả về như sau
```
{
  "data": {
    "hero": {
      "name": "R2-D2"
    },
    "droid": {
      "name": "C-3PO"
    }
  }
}
```

có nghĩa rằng là graphql phải có Query type với 2 trường là hero và droid 

```
type Query {
  hero(episode: Episode): Character
  droid(id: ID!): Droid
}
```

1. Query
- Được thiết kế sử dụng để đọc dữ liệu từ server
- Có nhiều trường
- Cấu trúc phân cấp
- Không có tác dụng phụ (không sửa đổi , thay thế dữ liệu)
2. Mutations
- Mutations sử dụng để sửa đổi dữ liệu trên máy chủ , nó giống như các method POST, PUT, PATCH, DELETE trong api rest thông thường.
- thường sẽ thực thi từ đợt
- Sẽ trả về một kết quả có thể trả về bao gồm thông tin về dữ liệu đã sửa đổi

### Scalar types
Lúc nãy có nhắc về Scalar, vậy đay là gì
Các loại đối tượng có tên và các trường , nhưng tại một số điểm các trường đó phân giải thành một số dữ liệu cụ thể . Lúc này Scalar type được xuất hiện 

Để biết rằng 1 trường có phải phân giải thành scalar type (vô hướng) hay không, có thể xem thông qua việc trường đó có trường con nào hay không (nếu không thì các trường này phân giải thành các type vô hướng

Graphql có tập hợp các loại vô hướng có sẵn:
- Int
- Float
- String
- Boolean
- ID : kiểu vô hướng ID đại diện  cho một mã định danh duy nhất thường được sử dụng để tìm nạp một đối tượng hoặc làm khoá cho bộ đệm.
- *loại ID được tuần tự hoá như chuỗi, tuy nhiên việc xac định ID biểu thị rằng nó nhằm mục đích không để con người đọc được*

Thông thường có thể chỉ định các loại vô hướng, ví dụ định nghĩa 1 scalar
```
scalar Date
```
## Inline Fragments


# Subscriptions 
Subscriptions là một operatios của graphql cho phép cập nhật theo thời gian thực từ máy chủ. Không giống như query và mutations, Subscriptions thiết lập kết nối liên tục qua websocket hoặc các giao thức được hỗ trợ khác. Kết nối này cho phép máy chủ đẩy các cập nhật đến máy khách ngay khi chúng xảy ra.

Ví dụ: 

tính năng like của facebook, mỗi tài khoản like 1 bài viết sẽ tăng 1 lượt like, để người dùng cập nhật ngay lặp tức số lượng like của bài viết khi có bất kỳ ai thực hiện like bài viết của người đó. Subscriptions cần thiết cho những lúc này.

### shorthand syntax
shorthand syntax được sử dụng trong graphql để viết câu truy vấn gọn hơn và dễ hiểu hơn

ví dụ:
```
{
  user {
    name
    age
    email
  }
}
```
-> 
```
{
  user {
    name, age, email
  }
}
```

### Variables
Trong các ví dụ ở trên đa phần các đối số được viết sẵn trong truy vấn. Tuy nhiên ở ứng dụng thực tế các đối số đường là dynamic tức nà được nhập vào hoặc được có sự chọn lọc

Nếu các tham số động này được chuyển thẳng vào trong truy vấn , các mã sẽ phải cần thao tác chuỗi truy vấn trong thời gian chạy và tuần tự hoá thành dạng riêng cho graphql, để tốt hơn cần phải chuyển các giá trị động này ra khỏi truy vấn và chuyển chúng dưới dạng riêng biệt, gọi là biến hay (variables)


```
query GetUser($userId: ID!) {
  user(id: $userId) {
    name
    email
    age
  }
}
```

ví dụ trên tên biến là userId được định nghĩa có kiểu dữ liệu ID! (non-null), Khi gửi truy vấn, bạn cần cung cấp giá trị cho biến
```
{
  "userId": "123"
}
```
